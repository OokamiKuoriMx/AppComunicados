<script>

    // =========================================================================
    // √ÅREA DE UTILIDADES Y CONFIGURACI√ìN
    // (Todas las "herramientas" y "planos" que usa la aplicaci√≥n)
    // =========================================================================

    // --- 1.1: Declaraciones de Estado Global ---
    // (Variables que se inicializar√°n en el PASO 1 de la L√≥gica Principal)
    let appRoot;
    let appLoader;
    let componentScriptAnchor;

    // ============================================================
    // üîß MODO DESARROLLO - Cambia este valor seg√∫n necesites
    // ============================================================
    // true  = Muestra todos los console.log en la consola
    // false = Oculta los logs (modo producci√≥n)
    const DEV_MODE = true;
    // ============================================================

    // Control de logging basado en DOMContentLoaded
    let isDOMReady = false;
    let logQueue = [];

    /**
     * Wrapper para console.log que solo imprime si DEV_MODE est√° activo
     * y √öNICAMENTE despu√©s de que DOMContentLoaded se haya disparado.
     * Los mensajes previos se encolan y se muestran cuando el DOM est√© listo.
     * Para desactivar logs: cambia DEV_MODE = false arriba.
     * @param {...any} args - Argumentos a imprimir.
     */
    function devLog(...args) {
        if (!DEV_MODE) return;

        if (isDOMReady) {
            console.log(...args);
        }
    }

    // Activar logging cuando el DOM est√© listo
    document.addEventListener('DOMContentLoaded', () => {
        isDOMReady = true;
        // Vaciar la cola de logs pendientes
        logQueue.forEach(args => console.log(...args));
        logQueue = [];
    }, { once: true });

    // --- 1.2: Caches Globales ---
    const TEMPLATES = Object.create(null); // Cache para plantillas de servidor
    const loadedScripts = new Set();      // Registro de scripts cargados

    // --- 1.3: Utilidad de Saneamiento ---
    /**
     * Escapa caracteres peligrosos de HTML para evitar XSS.
     * @param {string} s - Valor a convertir en string y escapar.
     * @returns {string} Cadena segura para insertar en el DOM.
     */
    function escapeHtml(s) {
        return String(s ?? '').replace(/[&<>"']/g, m => ({
            '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
        }[m]));
    }

    // --- 1.4: Definici√≥n de Componentes Est√°ticos ---
    // Componente Home (p√°gina de inicio)
    const Home = {
        render() {
            return `
        <section class="card shadow-sm">
          <div class="card-body">
            <h1 class="card-title">Inicio</h1>
            <p class="card-text">Bienvenido a la SPA modular. Esta aplicaci√≥n demuestra c√≥mo separar CSS y JS usando la funci√≥n include() en Google Apps Script.</p>
            <div id="appinfo" class="text-muted">Cargando informaci√≥n de la app‚Ä¶</div>
          </div>
        </section>
      `;
        },
        afterRender() {
            // Llama a la funci√≥n del servidor para obtener datos
            // IMPORTANTE: Retorna una promesa para bloquear hasta que cargue
            return new Promise((resolve, reject) => {
                google.script.run
                    .withSuccessHandler(info => {
                        const el = document.getElementById('appinfo');
                        if (el) el.innerHTML = `
                <strong>${escapeHtml(info.name || 'App')}</strong> v${escapeHtml(info.version || '1.0')}
                <br><span>Usuario: ${escapeHtml(info.user || 'an√≥nimo')}</span>
              `;
                        resolve(info);
                    })
                    .withFailureHandler(reject)
                    .getAppInfo();
            });
        }
    };

    // Componente Items (lista de √≠tems)
    const Items = {
        render() {
            return `
      <section class="card shadow-sm">
        <div class="card-body">
          <h1 class="card-title">Items</h1>
          <p class="card-text">Los datos se cargan din√°micamente desde el servidor (Google Sheets o datos de ejemplo).</p>
          <div id="items">Cargando...</div>
        </div>
      </section>
    `;
        },
        afterRender() {
            // Llama a la funci√≥n del servidor para obtener la lista de items
            google.script.run.withSuccessHandler(list => {
                const el = document.getElementById('items');
                if (!el) return;
                if (!list || !list.length) { el.textContent = 'No se encontraron datos.'; return; }

                const rows = list.map(o => `
        <tr>
          <td>${escapeHtml(o.id)}</td>
          <td>${escapeHtml(o.nombre)}</td>
          <td>${escapeHtml(o.estado)}</td>
        </tr>
      `).join('');

                el.innerHTML = `
        <table class="table table-striped table-hover">
          <thead><tr><th>ID</th><th>Nombre</th><th>Estado</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
      `;
            }).listItems();
        }
    };

    // Componente About (acerca de)
    const About = {
        render() {
            return `
        <section class="card shadow-sm">
          <div class="card-body">
            <h1 class="card-title">Acerca de</h1>
            <p class="card-text">Esta aplicaci√≥n usa Bootstrap 5 desde una CDN para los estilos y un enrutador por hash hecho en JavaScript para navegar entre las p√°ginas sin recargar.</p>
          </div>
        </section>
      `;
        }
    };

    // Componente NotFound (ruta no encontrada)
    const NotFound = {
        render() {
            return `
        <section class="card shadow-sm">
          <div class="card-body">
            <h1 class="card-title text-danger">404 - Ruta no encontrada</h1>
            <p class="card-text">La p√°gina que buscas no existe.</p>
            <a href="#/" class="btn btn-primary">Volver al inicio</a>
          </div>
        </section>
      `;
        }
    };

    // --- 1.5: Configuraci√≥n de Rutas ---
    // Configuracion del Router (rutas est√°ticas y din√°micas)
    /**
     * Rutas est√°ticas del enrutador: hash -> componente.
     * @type {Record<string, {render:Function, afterRender?:Function, mount?:Function}>}
     */
    const staticRoutes = {
        '#/': Home,
        '#/items': Items,
        '#/about': About
    };

    /**
     * Configuraci√≥n de rutas con carga diferida (lazy).
     * Cada ruta indica el nombre del script a cargar y la clave global expuesta.
     * @type {Record<string, {script:string, global:string, template?:string}>}
     */
    const lazyRouteConfigs = {
        '#/cuentas': { script: 'cuentas.js', global: 'Cuentas', template: 'cuentas' },
        '#/comunicados': { script: 'comunicados.js', global: 'Comunicados', template: 'comunicados' },
        '#/comunicado-detalle': { script: 'comunicado_detalle.js', global: 'ComunicadoDetalle', template: 'comunicado_detalle' }
    };

    // --- 1.6: Utiler√≠as de Carga y Servidor ---
    /**
     * Muestra u oculta el indicador de carga de la aplicaci√≥n.
     * Controla tambi√©n el atributo aria-busy del contenedor principal.
     * @param {boolean} isLoading - true para mostrar loader, false para ocultarlo.
     */
    function setAppLoading(isLoading) {
        if (!appLoader) return;
        if (isLoading) {
            appLoader.classList.remove('d-none');
            appRoot?.setAttribute('aria-busy', 'true');
        } else {
            appLoader.classList.add('d-none');
            appRoot?.removeAttribute('aria-busy');
        }
    }

    /**
     * Elimina un elemento del DOM por su id si existe.
     * @param {string} id - Id del elemento a eliminar.
     */
    function removeById(id) {
        const el = document.getElementById(id);
        if (el) el.remove();
    }

    /**
     * Quita del DOM el script del componente din√°mico actual (si existe).
     */
    function removeComponentScript() {
        const current = document.getElementById('componentScript');
        if (current) {
            current.remove();
        }
    }

    /**
     * Extrae el contenido JS de un bloque <script> o devuelve el texto tal cual.
     * @param {string} raw - Texto que puede contener un bloque <script>.
     * @returns {string} C√≥digo JavaScript listo para inyecci√≥n.
     */
    function extractScriptContent(raw) {
        if (!raw) return '';
        const text = String(raw).trim();
        if (!text) return '';
        const match = text.match(/<script[^>]*>([\s\S]*?)<\/script>/i);
        return match ? match[1].trim() : text;
    }

    /**
     * Inyecta c√≥digo JavaScript en la p√°gina como un <script> din√°mico.
     * Reemplaza el script previo del componente si existiera.
     * @param {string} code - C√≥digo JS a inyectar (o HTML con <script>).
     */
    function injectComponentScript(code) {
        if (!code) return;
        removeComponentScript();
        const scriptEl = document.createElement('script');
        scriptEl.id = 'componentScript';
        devLog(`Inyectando script de componente en ID:`, scriptEl);
        scriptEl.textContent = extractScriptContent(code);
        devLog(`Script inyectado`);
        (componentScriptAnchor?.parentNode || document.body || document.documentElement).appendChild(scriptEl);
    }

    /**
     * Obtiene del servidor (Apps Script) un fragmento identificado (plantilla o script).
     * @param {string} name - Nombre del fragmento en el bundle de plantillas.
     * @returns {Promise<string>} Resuelve al contenido solicitado o cadena vac√≠a.
     */
    function loadServerFragment(name) {
        return new Promise((resolve, reject) => {
            google.script.run
                .withSuccessHandler(result => {
                    if (result && result[name]) {
                        resolve(result[name]);
                    } else {
                        resolve('');
                    }
                })
                .withFailureHandler(reject)
                .getTemplates([name]);
        });
    }

    // --- 1.7: Utiler√≠as de Comunicaci√≥n (Google) ---
    // Funci√≥n para obtener plantillas del servidor con cach√©
    if (!globalThis.fetchTemplates) {
        /**
         * Fetch = Recupera y cachea una plantilla del lado servidor por nombre.
         * @param {string} name - Clave de la plantilla en Apps Script.
         * @returns {Promise<string|null>} HTML de la plantilla o null si no existe.
         * Ejemplo de uso:
         *   fetchTemplates('miPlantilla').then(html => { ... });
         * Devuelve:
         *  Promise que resuelve al HTML de la plantilla o null.
         */
        globalThis.fetchTemplates = function fetchTemplates(name) {
            if (!name) return Promise.resolve(null);
            if (TEMPLATES[name]) return Promise.resolve(TEMPLATES[name]);
            return new Promise((resolve, reject) => {
                google.script.run
                    .withSuccessHandler(result => {
                        const template = result && result[name] ? result[name] : null;
                        if (template) {
                            TEMPLATES[name] = template;
                        }
                        resolve(template);
                    })
                    .withFailureHandler(reject)
                    .getTemplates([name]);
            });
        };
    }

    // Funci√≥n gen√©rica para llamar funciones del servidor
    if (!globalThis.runServer) {
        /**
         * Ejecuta una funci√≥n p√∫blica del servidor (Apps Script) por su nombre.
         * @template T
         * @param {string} functionName - Nombre de la funci√≥n en google.script.run.
         * @param {...any} args - Argumentos a enviar a la funci√≥n del servidor.
         * @returns {Promise<T>} Promesa con el valor retornado por el servidor.
         * Ejemplo de uso:
         *   runServer('miFuncion', arg1, arg2).then(resultado => {
         * Devuelve:
         *  Promise que resuelve al valor retornado por la funci√≥n del servidor.
         */
        globalThis.runServer = function runServer(functionName, ...args) {
            return new Promise((resolve, reject) => {
                const runner = google.script.run
                    .withSuccessHandler(resolve)
                    .withFailureHandler(reject);
                if (typeof runner[functionName] === 'function') {
                    runner[functionName](...args);
                } else {
                    reject(new Error(`Funci√≥n de servidor "${functionName}" no encontrada.`));
                }
            });
        };
    }

    // Funci√≥n gen√©rica avanzada para llamar funciones del servidor con manejo detallado de errores
    if (!globalThis.serverCall) {
        /**
         * Invoca funciones del servidor esperando la convenci√≥n { success, data }.
         * En caso de error o respuesta inesperada, rechaza con un Error enriquecido.
         * @template T
         * @param {string} funcName - Nombre de la funci√≥n en Apps Script.
         * @param {...any} args - Argumentos que se pasan al servidor.
         * @returns {Promise<T>} Resuelve con response.data cuando success = true.
         * Ejemplo de uso:
         *   serverCall('miFuncion', arg1, arg2).then(data => {
         * Devuelve:
         *  Promise que resuelve al valor retornado response.data cuando success es true.
         */
        globalThis.serverCall = function serverCall(funcName, ...args) {
            // --- INICIO DE LA FUNCI√ìN ---

            // Imprime en la consola qu√© funci√≥n del servidor se est√° llamando y con qu√© argumentos.
            // Es una ayuda para depurar (debug).
            devLog(`Invocando serverCall a ${funcName} con argumentos:`, args);

            // Crea y devuelve una nueva Promesa. Esto es lo que te permite usar "await"
            // en lugar de los antiguos ".withSuccessHandler".
            return new Promise((resolve, reject) => {

                // Aqu√≠ es donde realmente se llama a Google Apps Script.
                google.script.run

                    // --- BLOQUE 1: EL "SUCCESS HANDLER" (El 99% de la l√≥gica) ---
                    // Esto se ejecuta SOLAMENTE si el servidor respondi√≥ (incluso si fue un error).
                    .withSuccessHandler(response => {

                        // Log para saber qu√© respondi√≥ el servidor.
                        devLog(`serverCall ${funcName}: respuesta recibida`, response);

                        // --- CASO 1: √âXITO TOTAL ---
                        // Comprueba si la respuesta existe Y si tiene la propiedad "success: true".
                        // Este es el "contrato" que tu servidor debe cumplir.
                        if (response && response.success) {
                            devLog(`serverCall ${funcName}: respuesta exitosa`, response);

                            // Resuelve la promesa con los datos reales (desenvuelve "response.data").
                            // Esto es lo que recibir√° tu "await".
                            resolve(response.data);

                            // Termina la ejecuci√≥n de esta funci√≥n.
                            return;
                        }

                        // --- CASO 2: FALLA SILENCIOSA (EL PEOR ERROR) ---
                        // Comprueba si la respuesta fue "null" o "undefined".
                        const isNullish = response === null || response === undefined;

                        // Si es "null", significa que tu funci√≥n en el servidor olvid√≥ un "return".
                        if (isNullish) {
                            console.error(`serverCall ${funcName}: la funci√≥n devolvi√≥ una respuesta vac√≠a (null/undefined).`, { args });

                            // Rechaza la promesa con un error MUY espec√≠fico y √∫til.
                            reject(new Error(`La funci√≥n ${funcName} devolvi√≥ una respuesta vac√≠a. Verifica que retorne un objeto { success, data }.`));

                            // Termina la ejecuci√≥n.
                            return;
                        }

                        // --- CASO 3: FALLA CONTROLADA (Error de la app) ---
                        // Si llegamos aqu√≠, "response" existe pero NO tiene "success: true".
                        // (Ej. { success: false, error: "Usuario no encontrado" })
                        if (DEV_MODE) console.error(`serverCall ${funcName}: respuesta sin √©xito`, response);

                        // Prepara variables para construir un mensaje de error claro.
                        let message = '';
                        let errorTrace = []; // Para guardar un posible stack trace del servidor.

                        // Revisa si la respuesta es un objeto para poder leer sus propiedades.
                        if (response && typeof response === 'object') {

                            // Intenta obtener el mensaje de error de "response.message" o "response.error".
                            message = response.message || response.error || '';

                            // Si "message" sigue vac√≠o, es una respuesta inesperada.
                            if (!message) {
                                try {
                                    // Intenta convertir el objeto de respuesta en texto JSON.
                                    message = `Respuesta inesperada: ${JSON.stringify(response)}`;
                                } catch (jsonError) {
                                    // Si ni siquiera se puede convertir a JSON, usa un mensaje gen√©rico.
                                    message = 'Respuesta inesperada sin contenido legible.';
                                }
                            }

                            // Si el servidor incluy√≥ un "errorTrace" (pila de errores), gu√°rdalo.
                            if (Array.isArray(response.errorTrace)) {
                                errorTrace = response.errorTrace;
                            }
                        }

                        // Construye el mensaje de error final que ver√° el programador.
                        const finalMessage = message
                            ? `Error en ${funcName}: ${message}` // Ej: "Error en leerUsuario: Usuario no encontrado"
                            : `Error en la operaci√≥n: ${funcName}.`; // Mensaje de √∫ltimo recurso.

                        // Crea un objeto Error real de JavaScript con ese mensaje.
                        const enrichedError = new Error(finalMessage);

                        // Si la respuesta fue un objeto, a√±ade la informaci√≥n extra al error.
                        if (response && typeof response === 'object') {
                            enrichedError.errorTrace = errorTrace; // El stack trace del servidor.
                            enrichedError.rawResponse = response;  // La respuesta completa para depurar.
                        }

                        // Rechaza la promesa con este error "enriquecido".
                        reject(enrichedError);
                    })

                    // --- BLOQUE 2: EL "FAILURE HANDLER" (La falla catastr√≥fica) ---
                    // Esto se ejecuta si la llamada NUNCA lleg√≥ al servidor o si el servidor "explot√≥".
                    // (Ej. Sin internet, el servidor crashe√≥, la funci√≥n no existe).
                    .withFailureHandler(error => {

                        // Log para saber que fue una falla de invocaci√≥n.
                        console.error(`serverCall ${funcName}: fallo en la invocaci√≥n`, error);

                        // Intenta obtener un mensaje de error √∫til.
                        const message = error?.message
                            ? `${error.message} (funci√≥n ${funcName})` // A√±ade el nombre de la funci√≥n al error.
                            : `Error inesperado al invocar ${funcName}`; // Mensaje gen√©rico.

                        // Asegura que "enrichedError" sea siempre un objeto "Error" real.
                        let enrichedError = error instanceof Error ? error : new Error(message);
                        if (!(enrichedError instanceof Error)) {
                            enrichedError = new Error(message);
                        }

                        // Si el error original ten√≠a un stack trace, lo preservamos.
                        if (error && typeof error === 'object' && Array.isArray(error.errorTrace)) {
                            enrichedError.errorTrace = error.errorTrace;
                        }

                        // Asegura que el error final siempre tenga un mensaje.
                        if (!enrichedError.message) {
                            enrichedError.message = message;
                        }

                        // Rechaza la promesa con el error de la falla.
                        reject(enrichedError);
                    })

                // --- LA LLAMADA FINAL ---
                // Finalmente, ejecuta la funci√≥n del servidor (cuyo nombre est√° en "funcName")
                // y le pasa todos los argumentos (que est√°n en "...args").
                [funcName](...args);
            });
        };
    }

    // API espec√≠fica para el componente Cuentas
    if (!globalThis.serverApi) {
        globalThis.serverApi = {
            /**
             * Lee la lista de cuentas desde el servidor (hoja de c√°lculo).
             * @returns {Promise<any[]>} Arreglo de cuentas.
             */
            readCuentas() {
                return new Promise((resolve, reject) => {
                    google.script.run
                        .withSuccessHandler(resolve)
                        .withFailureHandler(reject)
                        .readCuentas();
                });
            },
            /**
             * Lee todos los comunicados enriquecidos.
             * @returns {Promise<any>} Respuesta {success, data, message}
             */
            readAllComunicados() {
                return globalThis.serverCall('readAllComunicados');
            }
        };
    }


    // =========================================================================
    // L√ìGICA PRINCIPAL (EL ORQUESTADOR DE 7 PASOS)
    // (El "qu√©" y "cu√°ndo" se hacen las cosas, usando las utiler√≠as de arriba)
    // =========================================================================

    /**
     * PASO 1: Inicializa referencias del DOM para la app y puntos de inyecci√≥n.
     * @returns {void}
     */
    function app_Init() {
        devLog('--- PASO 1: Inicio de la Aplicaci√≥n ---');
        appRoot = document.getElementById('app');
        appLoader = document.getElementById('app-loader');
        componentScriptAnchor = document.getElementById('componentScript');
        devLog('‚úÖ PASO 1 completado');
    }


    /**
     * PASO 2: Resuelve un hash a un componente. Carga JS si la ruta es lazy.
     * @param {string} hash - Hash actual (ej. "#/", "#/cuentas").
     * @returns {Promise<object>} Componente que implementa al menos render().
     */
    async function app_ResolveRoute(hash) {
        devLog(`--- PASO 2: Resolviendo Ruta [${hash}] ---`);

        if (staticRoutes[hash]) {
            devLog('‚úÖ PASO 2 completado (Ruta Est√°tica)');
            return staticRoutes[hash]; // Retorna el componente est√°tico
        }

        if (lazyRouteConfigs[hash]) {
            // Es una ruta din√°mica (lazy), necesitamos cargar su script
            const config = lazyRouteConfigs[hash];
            devLog(`Ruta din√°mica detectada. Config:`, config);

            // --- Sub-paso de Adquisici√≥n de JS ---
            if (config.script && !loadedScripts.has(config.script)) {
                try {
                    const code = await loadServerFragment(config.script);
                    devLog(`Script cargado para ${hash}:`, code);
                    devLog(`Inyectando script para ${hash}...`);
                    injectComponentScript(code);
                    loadedScripts.add(config.script);
                } catch (err) {
                    console.error(`Fallo al cargar script para ${hash}`, err);
                    return NotFound; // Falla y muestra 404
                }
            }
            // --- Fin Sub-paso ---

            const component = globalThis[config.global];
            if (component) {
                devLog('‚úÖ PASO 2 completado (Ruta Din√°mica)');
                return component;
            } else {
                console.error(`Script ${config.script} cargado, pero global.${config.global} no se encontr√≥.`);
                return NotFound; // Falla y muestra 404
            }
        }

        devLog('‚úÖ PASO 2 completado (Ruta No Encontrada)');
        return NotFound; // 404
    }


    /**
     * PASO 3: Descarga la plantilla HTML asociada a la ruta si no est√° cacheada.
     * No falla duro si hay error; deja que el render maneje fallback.
     * @param {string} hash - Hash actual de navegaci√≥n.
     * @returns {Promise<void>}
     */
    async function app_AcquireTemplate(hash) {
        devLog(`--- PASO 3: Adquiriendo Plantilla [${hash}] ---`);
        const config = lazyRouteConfigs[hash];

        // Si es una ruta din√°mica Y su plantilla no est√° en cach√©
        if (config && config.template && !TEMPLATES[config.template]) {
            try {
                await fetchTemplates(config.template); // Carga y guarda en cach√©
                devLog('‚úÖ PASO 3 completado (Plantilla descargada)');
            } catch (err) {
                if (DEV_MODE) console.error(`‚ùå PASO 3 Fallo al cargar plantilla ${config.template}`, err);
                // No retornamos, `render` fallar√° y mostrar√° su propio error
            }
        } else {
            devLog('‚úÖ PASO 3 completado (Est√°tica o en Cach√©)');
        }
    }

    /**
     * PASO 4: Inyecta el HTML base del componente en el contenedor principal.
     * Limpia estilos y scripts del componente anterior y preserva unmount si existe.
     * @param {{render?:Function, renderizar?:Function, mount?:Function, despuesDeRenderizar?:Function, afterRender?:Function}} component - Componente a renderizar.
     * @returns {void}
     */
    function app_RenderTemplate(component) {
        devLog('--- PASO 4: Renderizando Plantilla ---');
        // Limpia el contenido anterior
        if (appRoot.__mounted && typeof appRoot.__mounted.unmount === 'function') {
            try { appRoot.__mounted.unmount(appRoot); } catch (e) { console.error('unmount error', e); }
        }
        removeById('component-script'); // Limpia scripts/estilos viejos
        removeById('component-style');

        const renderFn = typeof component.renderizar === 'function'
            ? component.renderizar
            : component.render;

        if (typeof renderFn === 'function') {
            appRoot.innerHTML = renderFn.call(component); // Llama a render()
        } else {
            appRoot.innerHTML = '<section class="card"><h1>Error: Componente sin render()</h1></section>';
        }

        appRoot.__mounted = component; // Guarda referencia para 'unmount'
        devLog('‚úÖ PASO 4 completado');
    }

    /**
     * PASO 5: MONTAJE Y CARGA DE DATOS (La Instalaci√≥n)
     * Llama a component.mount() para que el componente cargue sus datos internos.
     */
    /**
     * PASO 5: Ejecuta la fase de montaje del componente (carga de datos, listeners, etc.).
     * @param {{mount?:Function}} component - Componente renderizado.
     * @returns {Promise<void>}
     */
    async function app_MountComponent(component) {
        devLog('--- PASO 5: Montando Componente ---');
        if (typeof component.mount === 'function') {
            try {
                await component.mount(appRoot); // Llama a mount()
            } catch (e) {
                console.error('Error en mount():', e);
            }
        }
        devLog('‚úÖ PASO 5 completado');
    }

    /**
     * Marca visualmente el enlace del men√∫ correspondiente al hash actual.
     * Busca elementos '.nav a' y alterna la clase 'active'.
     * @returns {void}
     */
    function setActiveNav() {
        const hash = location.hash || '#/';
        document.querySelectorAll('.nav a').forEach(a => {
            a.classList.toggle('active', a.getAttribute('href') === hash);
        });
    }

    /**
     * PASO 6: TAREAS POST-MONTAJE (Limpieza y Verificaci√≥n)
     * Llama a afterRender() y actualiza la navegaci√≥n.
     */
    /**
     * PASO 6: Ejecuta tareas posteriores al montaje (afterRender) y marca navegaci√≥n activa.
     * @param {{afterRender?:Function, despuesDeRenderizar?:Function}} component - Componente actual.
     * @returns {void}
     */
    async function app_PostMountTasks(component) {
        devLog('--- PASO 6: Tareas Post-Montaje ---');
        const afterRenderFn = typeof component.despuesDeRenderizar === 'function'
            ? component.despuesDeRenderizar
            : component.afterRender;

        if (typeof afterRenderFn === 'function') {
            try {
                const result = afterRenderFn.call(component);
                // Si afterRender retorna una promesa, esperamos a que se complete
                if (result && typeof result.then === 'function') {
                    await result;
                }
            } catch (e) { console.error('afterRender error', e); }
        }

        setActiveNav(); // Actualiza el link activo del sidebar
        devLog('‚úÖ PASO 6 completado');
    }

    /**
    * PASO 7: APLICACI√ìN LISTA (Cierre del Proyecto)
    * Oculta el spinner de carga.
    */
    /**
    * PASO 7: Finaliza el ciclo de navegaci√≥n y oculta el estado de carga.
    * @returns {void}
    */
    function app_AppReady() {
        devLog('--- PASO 7: Aplicaci√≥n Lista ---');
        setAppLoading(false);
        devLog('‚úÖ PASO 7 completado');
        devLog('====================================\n\n');
    }

    // --- Funci√≥n Orquestadora (El "Director de Proyecto") ---
    // Esta funci√≥n llama a los 7 pasos en secuencia.
    async function navigate(hash) {
        devLog(`\n\n====================================`);
        devLog(`Navegando a: ${hash}`);

        // PASO 1: Inicializaci√≥n (ya hecho en app_Init, pero aqu√≠ gestionamos el loader global)
        setAppLoading(true);

        try {
            // PASO 2: Resolver Ruta y Cargar Componente (JS)
            // Esto devuelve el objeto componente (con sus m√©todos render, mount, etc.)
            const component = await app_ResolveRoute(hash);

            // PASO 3: Adquirir Plantilla (HTML)
            // Descarga la plantilla si es necesaria y no est√° en cach√©
            await app_AcquireTemplate(hash);

            // Ocultar loader global SI NO es la carga inicial
            // Esto permite que el componente muestre su propio loader (render())
            if (!isInitialLoad) {
                setAppLoading(false);
            }

            // PASO 4: Renderizar
            // Aqu√≠ se inserta el HTML en el DOM
            app_RenderTemplate(component);

            // PASO 5: Montaje y Carga de Datos
            // Llama a component.mount()
            await app_MountComponent(component);

            // PASO 6: Tareas Post-Montaje
            // Llama a afterRender y actualiza nav
            await app_PostMountTasks(component);

            // PASO 7: Aplicaci√≥n Lista
            // Solo si es carga inicial, ocultamos el loader aqu√≠.
            if (isInitialLoad) {
                app_AppReady();
            } else {
                devLog('--- Navegaci√≥n completada ---');
            }

        } catch (error) {
            console.error('Error en navegaci√≥n:', error);
            // En caso de error, aseguramos que el loader se oculte para mostrar el error
            setAppLoading(false);
            appRoot.innerHTML = `<div class="alert alert-danger">Error al cargar la vista: ${error.message}</div>`;
        }
    }

    // Bandera para evitar doble navegaci√≥n en la carga inicial
    let isInitialLoad = true;

    // 1. Escuchar futuros cambios de navegaci√≥n
    window.addEventListener('hashchange', () => {
        // Ignorar el primer hashchange si viene de la carga inicial
        if (isInitialLoad) {
            isInitialLoad = false;
            return;
        }
        navigate(location.hash).catch(err => console.error(err));
    });

    // 2. Iniciar la carga de la p√°gina por primera vez
    document.addEventListener('DOMContentLoaded', () => {
        devLog('Evento: DOMContentLoaded. Iniciando carga...');

        // PASO 1: Se ejecuta al inicio
        app_Init();

        // Asegura que siempre haya un hash ANTES de navegar
        if (!location.hash) {
            location.hash = '#/';
        }

        // Inicio de la primera navegaci√≥n manual
        // (El orquestador 'navigate' se encargar√° de los pasos 2 al 7)
        navigate(location.hash).catch(err => console.error(err));

        // Despu√©s de esta navegaci√≥n, ya no es carga inicial
        // (El pr√≥ximo hashchange real s√≠ debe disparar navigate)
        setTimeout(() => { isInitialLoad = false; }, 100);
    });
</script>
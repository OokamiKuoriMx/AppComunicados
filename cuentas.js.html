<script>
    /**
     * =================================================================
     * COMPONENTE DE GESTIÓN DE CUENTAS Y COMUNICADOS
     * =================================================================
     * Arquitectura en 7 Pasos Secuenciales para Carga Coordinada
     * 
     * REGLA: Cada paso DEBE completarse antes de que el siguiente comience.
     * Los pasos son atómicos e inmediatos.
     * 
     * FLUJO DE CARGA:
     * PASO 1: Crear estado inicial
     * PASO 2: Cargar HTML del componente
     * PASO 3: Inicializar DOM y event listeners
     * PASO 4: Cargar catálogos y cuentas en paralelo (Promise.all = 1 paso atómico)
     * PASO 5: Seleccionar primera cuenta
     * PASO 6: Cargar comunicados de la primera cuenta
     * PASO 7: Componente listo para usar
     * 
     * NOTA: Las funciones _load* son subfunciones/utilidades, NO pasos principales.
     * 
     * @version 4.0 (7 pasos secuenciales)
     */
    globalThis.Cuentas = (() => {
        'use strict';

        // =========================================================================
        // ESTADO GLOBAL Y UTILIDADES
        // =========================================================================

        let state = _estadoInicial();

        // Utilidad para llamadas al servidor
        const idsAreEqual = (a, b) => {
            if (a == null || b == null) return false;
            return String(a).trim() === String(b).trim();
        };

        // Utilidad para verificar si un valor tiene contenido
        const hasValue = (value) => {
            if (value == null) return false;
            return String(value).trim() !== '';
        };

        // Definición de fuentes de datos para comboboxes
        const COMBO_SOURCES = {
            estado: { catalog: 'estados', labelKeys: ['nombre', 'estado'] },
            distrito: { catalog: 'distritosRiego', labelKeys: ['distritoRiego', 'nombre'] },
            siniestro: { catalog: 'siniestros', labelKeys: ['nombre', 'siniestro'] },
            ajustador: { catalog: 'ajustadores', labelKeys: ['codigo', 'nombreAjustador', 'nombre', 'ajustador'] }
        };

        // =========================================================================
        // UTILIDADES DE RENDER INICIAL
        // =========================================================================

        const _renderSpinnerInicial = (container) => {
            container.innerHTML = `
            <div class="d-flex justify-content-center align-items-center" style="min-height: 400px;">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Cargando...</span>
                </div>
            </div>
        `;
        };

        const _renderErrorInicial = (container, message) => {
            container.innerHTML = `
            <div class="alert alert-danger">
                <h4>Error al cargar el componente</h4>
                <p>${message}</p>
            </div>
        `;
        };

        // =========================================================================
        // FUNCIONES DE RENDERIZADO
        // =========================================================================
        const _renderPlaceholder = (elementKey, title, subtitle) => {
            const element = state.dom[elementKey];
            if (!element) return;
            element.innerHTML = `
            <div class="border rounded p-4 text-center text-muted bg-light-subtle">
                <p class="mb-1 fw-semibold">${title}</p>
                <p class="mb-0 small">${subtitle}</p>
            </div>`;
        };

        const _renderSpinner = (elementKey, message) => {
            const element = state.dom[elementKey];
            if (!element) return;
            element.innerHTML = `
            <div class="border rounded p-4 text-center text-muted bg-light-subtle">
                <div class="spinner-border spinner-border-sm mb-2" role="status"></div>
                <p class="mb-0 small">${message}</p>
            </div>`;
        };

        const _buildErrorTraceDetails = (trace) => {
            if (!Array.isArray(trace) || !trace.length) {
                return '';
            }
            const items = trace.map(entry => {
                const level = escapeHtml(entry?.level ?? 'nivel');
                const name = escapeHtml(entry?.name ?? 'origen');
                const messageText = escapeHtml(entry?.message ?? 'Sin detalles disponibles');
                let contextHtml = '';
                if (entry && typeof entry.context === 'object' && entry.context !== null) {
                    const pairs = Object.keys(entry.context).map(key => `${escapeHtml(key)}=${escapeHtml(String(entry.context[key] ?? ''))}`);
                    if (pairs.length) {
                        contextHtml = `<div class="text-muted small">${pairs.join(', ')}</div>`;
                    }
                }
                return `<li><strong>${level}</strong> · ${name}: ${messageText}${contextHtml}</li>`;
            }).join('');
            return `<details class="mt-2"><summary>Detalles técnicos</summary><ul class="mt-2 small text-start mb-0">${items}</ul></details>`;
        };

        const _renderError = (elementKey, message, errorTrace = []) => {
            const element = state.dom[elementKey];
            if (!element) return;
            const safeMessage = escapeHtml(message || 'Ocurrió un error inesperado.');
            const details = _buildErrorTraceDetails(errorTrace);
            element.innerHTML = `<div class="alert alert-danger">${safeMessage}${details}</div>`;
        };

        const _renderCuentas = () => {
            const { dom, cuentas, cuentaSeleccionadaId } = state;
            if (!dom.listaCuentas) return;

            if (!cuentas.length) {
                _renderPlaceholder('listaCuentas', 'No hay referencias registradas', 'Agrega una referencia para comenzar.');
                return;
            }

            const html = cuentas.map(cuenta => {
                const cuentaId = cuenta.id;
                const isActive = idsAreEqual(cuentaId, cuentaSeleccionadaId);
                const accionesHtml = isActive ? `
                <div class="btn-group btn-group-sm">
                    <button type="button" class="btn btn-outline-secondary btn-edit" data-id="${cuenta.id}" title="Editar"><i class="bi bi-pencil"></i></button>
                    <button type="button" class="btn btn-outline-danger btn-delete" data-id="${cuenta.id}" data-nombre="${escapeHtml(cuenta.referencia)}" title="Eliminar"><i class="bi bi-trash"></i></button>
                </div>` : '';

                return `
                <div class="card account-item border ${isActive ? 'border-primary shadow-sm' : ''}" data-id="${cuenta.id}" role="listitem" style="cursor: pointer;">
                    <div class="card-body d-flex justify-content-between align-items-center gap-3 py-2">
                        <span class="fw-semibold">${escapeHtml(cuenta.referencia)}</span>
                        ${accionesHtml}
                    </div>
                </div>`;
            }).join('');
            dom.listaCuentas.innerHTML = html;
        };

        const _renderComunicados = () => {
            const { dom, comunicados, cuentaSeleccionadaId, comunicadoSeleccionadoId } = state;
            if (!dom.panelComunicados) return;

            if (!hasValue(cuentaSeleccionadaId)) {
                _renderPlaceholder('panelComunicados', 'Selecciona una referencia', 'Aquí verás sus comunicados.');
                return;
            }
            if (!comunicados.length) {
                _renderPlaceholder('panelComunicados', 'No hay comunicados', 'Agrega un comunicado para esta cuenta.');
                return;
            }

            const html = comunicados.map(com => {
                const comunicadoId = com.id;
                const isSelected = idsAreEqual(comunicadoId, comunicadoSeleccionadoId);
                const comunicadoNombre = escapeHtml(com?.comunicado ?? com?.comunicados?.comunicado ?? 'SIN COMUNICADO');
                const descripcion = escapeHtml(
                    com?.descripcion
                    ?? com?.datosGenerales?.descripcion
                    ?? 'Sin descripción'
                );
                const statusRaw = com?.status ?? com?.comunicado?.status ?? '';
                const statusLabel = escapeHtml(String(statusRaw || 'Sin estatus'));
                const seleccionadoBadge = isSelected
                    ? `<span class="badge text-bg-primary ms-md-2">Seleccionado</span>`
                    : '';

                return `
                <div class="card comunicado-item border ${isSelected ? 'border-primary shadow-sm' : ''}" data-id="${com.id}" style="cursor: pointer;">
                    <div class="card-body">
                        <div class="row align-items-center gy-2 gx-3">
                            <div class="col-md-4">
                                <div class="text-muted text-uppercase small">Comunicado</div>
                                <div class="fw-semibold">${comunicadoNombre}</div>
                            </div>
                            <div class="col-md-5">
                                <div class="text-muted text-uppercase small">Descripción</div>
                                <div>${descripcion}</div>
                            </div>
                            <div class="col-md-3 text-md-end">
                                <div class="text-muted text-uppercase small">Status</div>
                                <div class="d-flex justify-content-md-end align-items-center gap-2">
                                    <span class="badge text-bg-secondary">${statusLabel}</span>
                                    ${seleccionadoBadge}
                                </div>
                            </div>
                        </div>
                        <div class="text-end text-muted small mt-3">${escapeHtml(com?.fecha ?? '')}</div>
                    </div>
                </div>`;
            }).join('');
            dom.panelComunicados.innerHTML = html;
        };

        const _updateTotalCuentasBadge = () => {
            const { dom } = state;
            const total = state.cuentas.length;

            if (total > 0) {
                dom.badgeTotalCuentas.textContent = `${total} ${total === 1 ? 'referencia' : 'referencias'}`;
                dom.badgeTotalCuentas.hidden = false;
            } else {
                dom.badgeTotalCuentas.hidden = true;
            }
        };

        const _actualizarSeleccionCuenta = (cuenta, { cargarComunicados = false } = {}) => {
            state.cuentaSeleccionadaId = cuenta?.id ?? null;
            devLog('Cuenta seleccionada actualizada a ID:', state.cuentaSeleccionadaId);
            state.cuentaSeleccionadaNombre = cuenta?.referencia ?? '';
            devLog('Nombre de cuenta seleccionada:', state.cuentaSeleccionadaNombre);
            if (state.dom.btnNuevoComunicado) {
                state.dom.btnNuevoComunicado.disabled = !cuenta;
            }

            if (state.dom.badgeCuentaSeleccionada) {
                state.dom.badgeCuentaSeleccionada.textContent = cuenta ? cuenta.referencia : 'Sin referencia';
                state.dom.badgeCuentaSeleccionada.classList.toggle('text-bg-primary', !!cuenta);
                state.dom.badgeCuentaSeleccionada.classList.toggle('text-bg-secondary', !cuenta);
            }

            _renderCuentas();

            if (cargarComunicados) {
                _loadComunicados(cuenta?.id);
            }
        };

        const _actualizarSeleccionComunicado = (comunicado) => {
            state.comunicadoSeleccionadoId = comunicado?.id ?? null;
            _renderComunicados();
        };

        // =========================================================================
        // MANEJADORES DE EVENTOS (Para interacción del usuario DESPUÉS del PASO 7)
        // =========================================================================

        const _handlePanelCuentasClick = (event) => {
            const editBtn = event.target.closest('.btn-edit');
            if (editBtn) {
                const targetId = editBtn.dataset.id;
                const cuenta = state.cuentas.find(c => idsAreEqual(c.id, targetId));
                if (cuenta) _openCuentaModal(cuenta);
                return;
            }

            const deleteBtn = event.target.closest('.btn-delete');
            if (deleteBtn) {
                _openDeleteModal(deleteBtn.dataset.id, deleteBtn.dataset.nombre);
                return;
            }
            // Selección de cuenta
            const item = event.target.closest('.account-item');
            if (item) {
                const targetId = item.dataset.id;
                devLog('Seleccionando cuenta ID:', targetId);
                const cuenta = state.cuentas.find(c => idsAreEqual(c.id, targetId));
                devLog('Cuenta encontrada:', cuenta);
                _actualizarSeleccionCuenta(cuenta, { cargarComunicados: true });
            }
        };

        const _handlePanelComunicadosClick = (event) => {
            const item = event.target.closest('.comunicado-item');
            if (item) {
                const targetId = item.dataset.id;
                const comunicado = state.comunicados.find(c => idsAreEqual(c.id, targetId));
                _actualizarSeleccionComunicado(comunicado);
            }
        };

        const _handleCuentaClick = (cuentaId) => {
            const cuenta = state.cuentas.find(c => idsAreEqual(c.id, cuentaId));
            if (cuenta) {
                _actualizarSeleccionCuenta(cuenta, { cargarComunicados: true });
            }
        };

        const _handleComunicadoClick = (comunicadoId) => {
            const comunicado = state.comunicados.find(c => idsAreEqual(c.id, comunicadoId));
            if (comunicado) {
                _actualizarSeleccionComunicado(comunicado);
            }
        };

        const _handleNuevaCuentaClick = () => {
            _resetCuentaModal();
            state.modals.cuenta.show();
        };

        const _handleNuevoComunicadoClick = async () => {
            if (!hasValue(state.cuentaSeleccionadaId)) return;

            const btn = state.dom.btnNuevoComunicado;
            _setButtonLoading(btn, true, 'Cargando...');

            try {
                await _loadCatalogos();

                _resetComunicadoModal();
                state.dom.modalCuentaSeleccionada.textContent = state.cuentaSeleccionadaNombre;
                state.dom.comunicadoFecha.value = new Date().toISOString().slice(0, 10);

                _populateCatalogInputs();

                state.modals.comunicado.show();

            } catch (err) {
                _showModalError(err.message);
                globalThis.showToast?.('Error al cargar datos para el formulario.', 'error');
            } finally {
                _setButtonLoading(btn, false);
            }
        };

        const _openCuentaModal = async (cuenta = null) => {
            const { dom, modals } = state;
            dom.formCuenta?.classList.remove('was-validated');
            dom.formCuenta?.reset();

            const modalTitle = dom.modalCuenta ? dom.modalCuenta.querySelector('.modal-title') : null;
            if (modalTitle) {
                modalTitle.textContent = cuenta ? 'Editar Referencia' : 'Agregar Referencia';
            }
            const cuentaId = hasValue(cuenta?.id) ? cuenta.id : '';
            const cuentaIdInput = dom.modalCuenta?.querySelector('#cuentaId');
            const nombreCuentaInput = dom.modalCuenta?.querySelector('#nombreCuenta');
            if (cuentaIdInput) cuentaIdInput.value = cuentaId;
            if (nombreCuentaInput) nombreCuentaInput.value = cuenta?.referencia || '';

            // Cargar catálogos antes de mostrar el modal
            try {
                await _loadCatalogos();

                // Poblar el combobox de ajustador
                const ajustadorCombo = state.combos.ajustador;
                if (ajustadorCombo?.input && ajustadorCombo?.hidden) {
                    // Si estamos editando, buscar el ajustador actual
                    if (cuenta?.idAjustador) {
                        const ajustadorActual = state.catalogos.ajustadores.find(
                            a => String(a.id) === String(cuenta.idAjustador)
                        );
                        if (ajustadorActual) {
                            ajustadorCombo.input.value = ajustadorActual.codigo || ajustadorActual.nombreAjustador || ajustadorActual.nombre || ajustadorActual.ajustador || '';
                            ajustadorCombo.hidden.value = ajustadorActual.id;
                        } else {
                            ajustadorCombo.input.value = '';
                            ajustadorCombo.hidden.value = '';
                        }
                    } else {
                        ajustadorCombo.input.value = '';
                        ajustadorCombo.hidden.value = '';
                    }
                    // Renderizar sugerencias iniciales
                    _renderComboSuggestions('ajustador', '', { autoOpen: false });
                }
            } catch (err) {
                console.error('Error al cargar catálogos para modal:', err);
            }

            modals.cuenta?.show();
        };

        const _handleSubmitCuenta = async (event) => {
            event.preventDefault();
            const { dom, modals } = state;
            if (!dom.formCuenta?.checkValidity()) {
                dom.formCuenta?.classList.add('was-validated');
                return;
            }

            const id = dom.modalCuenta?.querySelector('#cuentaId')?.value;
            const nombreInput = dom.modalCuenta?.querySelector('#nombreCuenta');

            // Obtener datos del ajustador
            const ajustadorCombo = state.combos.ajustador;
            const ajustadorNombre = ajustadorCombo?.input?.value?.trim().toUpperCase() || '';
            let ajustadorId = ajustadorCombo?.hidden?.value || '';

            _setButtonLoading(dom.btnGuardarCuenta, true);
            try {
                // Si hay nombre de ajustador pero no ID, es un ajustador nuevo
                if (ajustadorNombre && !ajustadorId) {
                    devLog('Creando nuevo ajustador:', ajustadorNombre);
                    const ajustadorResult = await serverCall('ensureCatalogRecord', 'ajustadores', {
                        codigo: ajustadorNombre
                    });
                    if (ajustadorResult?.id) {
                        ajustadorId = ajustadorResult.id;
                        // Actualizar catálogo local si se creó uno nuevo
                        if (ajustadorResult.created) {
                            state.catalogos.ajustadores.push({
                                id: ajustadorId,
                                codigo: ajustadorNombre
                            });
                        }
                    }
                }

                // Preparar el registro completo
                const record = {
                    referencia: nombreInput?.value?.toUpperCase(),
                    idAjustador: ajustadorId || null
                };

                const operation = id ? 'updateRow' : 'createRow';
                const args = id ? ['cuentas', id, record] : ['cuentas', record];
                const savedData = await serverCall(operation, ...args);

                state.cuentaSeleccionadaId = savedData.id;
                modals.cuenta?.hide();
                globalThis.showToast?.(id ? 'Referencia actualizada.' : 'Referencia creada.');
                await _loadCuentas();
            } catch (error) {
                alert(`Error al guardar: ${error.message}`);
            } finally {
                _setButtonLoading(dom.btnGuardarCuenta, false);
            }
        };

        const _openDeleteModal = (id, nombre) => {
            const { dom, modals } = state;
            if (dom.deleteAccountName) {
                dom.deleteAccountName.textContent = nombre;
            }

            const originalBtn = dom.btnConfirmDelete;
            if (originalBtn?.parentNode) {
                const newBtn = originalBtn.cloneNode(true);
                originalBtn.parentNode.replaceChild(newBtn, originalBtn);
                state.dom.btnConfirmDelete = newBtn;
                newBtn.addEventListener('click', () => _confirmDelete(id), { once: true });
            }

            modals.delete?.show();
        };

        const _confirmDelete = async (id) => {
            const { dom, modals } = state;
            _setButtonLoading(dom.btnConfirmDelete, true, 'Eliminando...');
            try {
                await serverCall('deleteRow', 'cuentas', id);
                if (idsAreEqual(state.cuentaSeleccionadaId, id)) {
                    state.cuentaSeleccionadaId = null;
                }
                modals.delete?.hide();
                globalThis.showToast?.('Referencia eliminada.');
                await _loadCuentas();
            } catch (error) {
                alert(`Error al eliminar: ${error.message}`);
            } finally {
                _setButtonLoading(dom.btnConfirmDelete, false);
            }
        };

        const _handleSubmitComunicado = async (event) => {
            event.preventDefault();
            const { dom, modals } = state;
            _clearModalAlerts();

            if (!dom.formComunicado?.checkValidity()) {
                dom.formComunicado?.classList.add('was-validated');
                return;
            }

            for (const key of Object.keys(state.combos)) {
                _handleComboInput(key);
            }

            const estadoMatch = _matchCatalogRecord('estado', _getComboCatalog('estado'), dom.comunicadoEstado?.value);
            if (!estadoMatch) {
                _showModalError('El estado debe coincidir con un valor del catálogo.');
                return;
            }

            const distritoMatch = _matchCatalogRecord('distrito', _getComboCatalog('distrito'), dom.comunicadoDistrito?.value);
            const siniestroMatch = _matchCatalogRecord('siniestro', _getComboCatalog('siniestro'), dom.comunicadoSiniestro?.value);

            const payload = {
                idCuenta: state.cuentaSeleccionadaId,
                comunicado: dom.comunicadoNombre?.value,
                descripcion: dom.comunicadoDescripcion?.value,
                fecha: dom.comunicadoFecha?.value,
                estado: dom.comunicadoEstado?.value,
                estadoId: estadoMatch?.id || dom.comunicadoEstadoId?.value || '',
                distrito: dom.comunicadoDistrito?.value,
                distritoId: distritoMatch?.id || dom.comunicadoDistritoId?.value || '',
                siniestro: dom.comunicadoSiniestro?.value,
                siniestroId: siniestroMatch?.id || dom.comunicadoSiniestroId?.value || '',
                esNuevoSiniestro: state.isNuevoSiniestro,
                fenomeno: dom.siniestroFenomeno?.value,
                fi: dom.siniestroFi?.value
            };

            _setButtonLoading(dom.btnGuardarComunicado, true);
            try {
                await serverCall('createComunicado', payload);
                modals.comunicado?.hide();
                globalThis.showToast?.('Comunicado guardado.');
                await _loadComunicados(state.cuentaSeleccionadaId);
            } catch (error) {
                _showModalError(error.message);
            } finally {
                _setButtonLoading(dom.btnGuardarComunicado, false);
            }
        };

        const _handleEditarCuentaClick = (cuentaId) => {
            const cuenta = state.cuentas.find(c => idsAreEqual(c.id, cuentaId));
            if (cuenta) {
                _openCuentaModal(cuenta);
            }
        };

        const _handleEliminarCuentaClick = (cuentaId) => {
            const cuenta = state.cuentas.find(c => idsAreEqual(c.id, cuentaId));
            if (cuenta) {
                _openDeleteModal(cuenta.id, cuenta.referencia);
            }
        };

        // =========================================================================
        // FUNCIONES AUXILIARES
        // =========================================================================

        const _resetCuentaModal = () => {
            state.dom.formCuenta?.reset();
            state.dom.formCuenta?.classList.remove('was-validated');
        };

        const _resetComunicadoModal = () => {
            state.dom.formComunicado?.reset();
            state.dom.formComunicado?.classList.remove('was-validated');
            _clearModalAlerts();
            _toggleSiniestroExtras(false);
            Object.keys(state.combos).forEach(_hideComboSuggestions);
        };

        const _clearModalAlerts = () => {
            state.dom.alertErrorComunicado?.classList.add('d-none');
            state.dom.alertInfoComunicado?.classList.add('d-none');
        };

        const _showModalError = (message) => {
            const alert = state.dom.alertErrorComunicado;
            if (alert) {
                alert.textContent = message;
                alert.classList.remove('d-none');
            }
        };

        const _showModalInfo = (message) => {
            const alert = state.dom.alertInfoComunicado;
            if (alert) {
                alert.textContent = message;
                alert.classList.remove('d-none');
            }
        };

        const _setButtonLoading = (button, isLoading, loadingLabel = 'Guardando...') => {
            if (!button) return;
            if (isLoading) {
                button.dataset.originalContent = button.innerHTML;
                button.disabled = true;
                button.innerHTML = `<span class="spinner-border spinner-border-sm me-2"></span>${loadingLabel}`;
            } else {
                if (button.dataset.originalContent) {
                    button.innerHTML = button.dataset.originalContent;
                }
                button.disabled = false;
            }
        };

        const _toggleSiniestroExtras = (show) => {
            state.isNuevoSiniestro = show;
            state.dom.wrapperSiniestroExtra?.classList.toggle('d-none', !show);
        };

        const _populateCatalogInputs = () => {
            if (!state.catalogosLoaded) return;
            Object.keys(state.combos).forEach(key => {
                const combo = state.combos[key];
                const isFocused = document.activeElement === combo.input;
                _renderComboSuggestions(key, combo.input?.value || '', { autoOpen: isFocused });
            });
        };

        const _initCombobox = (key) => {
            const combo = state.combos[key];

            // El ajustador usa prefijo 'referencia', los demás usan 'comunicado'
            let domKey;
            if (key === 'ajustador') {
                domKey = 'referenciaAjustador';
            } else {
                domKey = `comunicado${key.charAt(0).toUpperCase() + key.slice(1)}`;
            }

            combo.input = state.dom[domKey];
            combo.hidden = state.dom[`${domKey}Id`];
            combo.suggestions = state.dom[`${key}Suggestions`];
            combo.wrapper = combo.input?.closest('.combobox-dropdown');

            if (!combo.input || !combo.suggestions) return;

            if (window.bootstrap?.Dropdown) {
                combo.dropdownInstance = new bootstrap.Dropdown(combo.input, { autoClose: 'outside' });
            }

            combo.input.addEventListener('click', (event) => {
                event.preventDefault();
                _handleComboInput(key, { fromFocus: true });
            });
            combo.input.addEventListener('input', () => _handleComboInput(key));
            combo.input.addEventListener('focus', () => _handleComboInput(key, { fromFocus: false }));
            combo.input.addEventListener('blur', () => _handleComboBlur(key));
            combo.input.addEventListener('keydown', (event) => _handleComboKeyDown(key, event));

            combo.suggestions.addEventListener('mousedown', (event) => event.preventDefault());
            combo.suggestions.addEventListener('click', (event) => {
                const target = event.target.closest('.dropdown-item');
                if (target) {
                    _selectComboByIndex(key, Number(target.dataset.index));
                }
            });
        };

        const _initComboboxes = () => {
            Object.keys(COMBO_SOURCES).forEach(key => {
                state.combos[key] = {
                    items: [],
                    activeIndex: -1,
                    hideTimeout: null
                };
                _initCombobox(key);
            });
        };

        const _handleComboInput = (key, { fromFocus = false } = {}) => {
            const combo = state.combos[key];
            if (!combo) return;

            clearTimeout(combo.hideTimeout);
            const value = normalizeClientText(combo.input.value, { uppercase: true });
            combo.input.value = value;

            _renderComboSuggestions(key, value, { autoOpen: true });
        };

        const _handleComboBlur = (key) => {
            const combo = state.combos[key];
            if (!combo) return;

            combo.hideTimeout = setTimeout(() => _hideComboSuggestions(key), 150);

            const value = combo.input.value;
            const match = _matchCatalogRecord(key, _getComboCatalog(key), value);
            _applyComboMatch(key, match, value);
        };

        const _renderComboSuggestions = (key, filterText = '', { autoOpen = false } = {}) => {
            const combo = state.combos[key];
            if (!combo) return;

            const normalizedFilter = normalizeForLookup(filterText);
            const catalog = _getComboCatalog(key);
            const items = catalog
                .filter(item => {
                    const label = normalizeForLookup(_extractComboLabel(key, item));
                    return !normalizedFilter || label.includes(normalizedFilter);
                })
                .slice(0, 10);

            combo.items = items;
            combo.activeIndex = items.length > 0 ? 0 : -1;

            if (!items.length) {
                _hideComboSuggestions(key);
                return;
            }

            const html = items.map((item, index) => {
                const label = _extractComboLabel(key, item);
                const isActive = index === combo.activeIndex;
                return `<button type="button" class="dropdown-item ${isActive ? 'active' : ''}" role="option" data-index="${index}">${escapeHtml(label)}</button>`;
            }).join('');

            combo.suggestions.innerHTML = html;

            if (autoOpen && combo.dropdownInstance) {
                combo.dropdownInstance.show();
            }
        };

        const _hideComboSuggestions = (key) => {
            const combo = state.combos[key];
            if (combo?.dropdownInstance) {
                combo.dropdownInstance.hide();
            }
        };

        const _selectComboByIndex = (key, index, { focusInput = true } = {}) => {
            const combo = state.combos[key];
            const record = combo?.items?.[index];
            if (!record || !combo.input) return;

            const label = _extractComboLabel(key, record);
            combo.input.value = label;
            _applyComboMatch(key, record, label);
            _hideComboSuggestions(key);
            if (focusInput) {
                combo.input.focus();
            }
        };

        const _applyComboMatch = (key, match, value) => {
            const combo = state.combos[key];
            const hidden = combo.hidden;
            if (!hidden) return;

            hidden.value = match?.id ?? '';

            if (key === 'siniestro') {
                const esNuevo = !match && !!value;
                _toggleSiniestroExtras(esNuevo);
                if (esNuevo) {
                    _showModalInfo('El siniestro no está registrado y se creará uno nuevo.');
                } else if (state.dom.alertInfoComunicado?.textContent?.includes('siniestro')) {
                    _clearModalAlerts();
                }
            }
        };

        const _handleComboKeyDown = (key, event) => {
            const combo = state.combos[key];
            if (!combo) return;

            if (!combo.dropdownInstance || !combo.wrapper?.classList.contains('show')) {
                if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    _renderComboSuggestions(key, combo.input.value, { autoOpen: true });
                    event.preventDefault();
                }
                return;
            }

            const items = combo.suggestions.querySelectorAll('.dropdown-item');
            if (!items.length) return;

            let newIndex = combo.activeIndex;

            if (event.key === 'ArrowDown') {
                newIndex = (newIndex + 1) % items.length;
            } else if (event.key === 'ArrowUp') {
                newIndex = (newIndex - 1 + items.length) % items.length;
            } else if (event.key === 'Enter') {
                if (combo.activeIndex !== -1) {
                    event.preventDefault();
                    _selectComboByIndex(key, combo.activeIndex);
                }
                return;
            } else if (event.key === 'Tab') {
                if (combo.activeIndex !== -1) {
                    event.preventDefault();
                    _selectComboByIndex(key, combo.activeIndex, { focusInput: false });
                    setTimeout(() => {
                        const form = combo.input.form;
                        if (form) {
                            const elements = Array.from(form.elements).filter(el => el.offsetParent !== null && !el.disabled && el.tabIndex !== -1);
                            const idx = elements.indexOf(combo.input);
                            if (idx !== -1 && idx + 1 < elements.length) {
                                elements[idx + 1].focus();
                            }
                        }
                    }, 0);
                }
                return;
            } else if (event.key === 'Escape') {
                _hideComboSuggestions(key);
                return;
            } else {
                return;
            }

            event.preventDefault();

            if (combo.activeIndex !== -1) items[combo.activeIndex]?.classList.remove('active');
            items[newIndex]?.classList.add('active');
            items[newIndex]?.scrollIntoView({ block: 'nearest' });
            combo.activeIndex = newIndex;
        };

        const _extractComboLabel = (key, item) => {
            if (!item) return '';
            const source = COMBO_SOURCES[key];
            for (const candidate of source?.labelKeys || ['nombre']) {
                if (item[candidate] != null) {
                    return normalizeClientText(item[candidate], { uppercase: true });
                }
            }
            return '';
        };

        const _matchCatalogRecord = (key, collection, value) => {
            if (!Array.isArray(collection) || !value) return null;
            const target = normalizeForLookup(value);
            return collection.find(item => normalizeForLookup(_extractComboLabel(key, item)) === target) || null;
        };

        const _getComboCatalog = (key) => {
            const source = COMBO_SOURCES[key];
            return source ? (state.catalogos?.[source.catalog] || []) : [];
        };

        const escapeHtml = (unsafe) => {
            return String(unsafe ?? '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        };

        const normalizeForLookup = (value) => String(value ?? '').normalize('NFD').replace(/[\u0300-\u036f]/g, '').trim().toUpperCase();

        const normalizeClientText = (value, { uppercase = false } = {}) => {
            let text = String(value ?? '').replace(/\s+/g, ' ').trim();
            return uppercase ? text.toUpperCase() : text;
        };



        // =========================================================================
        // FUNCIONES DEL PASO 1
        // =========================================================================
        // Configuracion del estado inicial
        /**
         * Genera un nuevo estado base para el componente.
         * Se usa en el PASO 1 y cada vez que se desmonta el módulo.
         */
        function _estadoInicial() {
            return {
                cuentas: [],
                comunicados: [],
                catalogos: { estados: [], distritosRiego: [], siniestros: [], ajustadores: [] },
                catalogosLoaded: false,
                catalogosPromise: null,
                cuentaSeleccionadaId: null,
                cuentaSeleccionadaNombre: '',
                comunicadoSeleccionadoId: null,
                dom: {},
                modals: {},
                combos: {
                    estado: { items: [], activeIndex: -1, hideTimeout: null },
                    distrito: { items: [], activeIndex: -1, hideTimeout: null },
                    siniestro: { items: [], activeIndex: -1, hideTimeout: null },
                    ajustador: { items: [], activeIndex: -1, hideTimeout: null }
                },
                isNuevoSiniestro: false
            };
        }

        // FUNCIÓN PRINCIPAL DEL PASO 1
        const _defEstadoInicial = () => {
            state = _estadoInicial();
            console.log('✅ PASO 1 completado');
        };

        // =========================================================================
        // FUNCIONES DEL PASO 2
        // =========================================================================
        // Montaje del componente en el contenedor destino
        const _mount = async (container) => {
            console.log('=== PASO 2: Cargar HTML del componente ===');
            _renderSpinnerInicial(container);

            try {
                await new Promise((resolve, reject) => {
                    google.script.run
                        .withSuccessHandler(html => {
                            container.innerHTML = html;
                            console.log('✅ PASO 2 completado');
                            resolve(html);
                        })
                        .withFailureHandler(error => {
                            reject(error);
                        })
                        .include('cuentas');
                });
            } catch (error) {
                console.error('❌ PASO 2 falló:', error);
                _renderErrorInicial(container, error.message || 'No fue posible cargar el componente.');
                throw error;
            }
        };

        // =========================================================================
        // FUNCIONES DEL PASO 3
        // =========================================================================
        // SUBFUNCIÓN: Cachea elementos del DOM para evitar búsquedas repetidas.
        const _cacheDomElements = () => {
            const dom = {};
            const ids = [
                'modalCuenta', 'form-cuenta', 'modalConfirmDelete', 'deleteAccountName', 'btnConfirmDelete',
                'lista-cuentas', 'panel-comunicados', 'badgeCuentaSeleccionada', 'badgeTotalCuentas', 'btnNuevoComunicado', 'btnGuardarCuenta',
                'modalNuevoComunicado', 'form-comunicado', 'modalCuentaSeleccionada', 'comunicadoNombre', 'comunicadoDescripcion',
                'comunicadoFecha', 'comunicadoEstado', 'comunicadoEstadoId', 'estadoSuggestions', 'comunicadoDistrito',
                'comunicadoDistritoId', 'distritoSuggestions', 'comunicadoSiniestro', 'comunicadoSiniestroId', 'siniestroSuggestions',
                'wrapperSiniestroExtra', 'alertErrorComunicado', 'alertInfoComunicado', 'btnGuardarComunicado', 'siniestroFenomeno', 'siniestroFi',
                'referenciaAjustador', 'referenciaAjustadorId', 'ajustadorSuggestions'
            ];
            ids.forEach(id => {
                const key = id.replace(/-(\w)/g, (_, c) => c.toUpperCase());
                dom[key] = document.getElementById(id);
            });
            dom.listaCuentas = dom.listaCuentas || document.getElementById('lista-cuentas');
            dom.panelComunicados = dom.panelComunicados || document.getElementById('panel-comunicados');
            state.dom = dom;
        };

        // SUBFUNCIÓN: Inicializa las instancias de los modales de Bootstrap.
        const _initBootstrapInstances = () => {
            if (state.dom.modalCuenta) {
                state.modals.cuenta = new bootstrap.Modal(state.dom.modalCuenta);
            }
            if (state.dom.modalNuevoComunicado) {
                state.modals.comunicado = new bootstrap.Modal(state.dom.modalNuevoComunicado);
            }
            if (state.dom.modalConfirmDelete) {
                state.modals.delete = new bootstrap.Modal(state.dom.modalConfirmDelete);
            }
        };

        // SUBFUNCIÓN: Agrega los event listeners necesarios para la interacción del usuario.
        const _addEventListeners = () => {
            const { dom } = state;

            dom.listaCuentas?.addEventListener('click', _handlePanelCuentasClick);
            dom.panelComunicados?.addEventListener('click', _handlePanelComunicadosClick);

            dom.formCuenta?.addEventListener('submit', _handleSubmitCuenta);
            dom.formComunicado?.addEventListener('submit', _handleSubmitComunicado);

            dom.btnNuevoComunicado?.addEventListener('click', _handleNuevoComunicadoClick);

            dom.modalCuenta?.addEventListener('hidden.bs.modal', _resetCuentaModal);
            dom.modalNuevoComunicado?.addEventListener('hidden.bs.modal', _resetComunicadoModal);
            dom.modalNuevoComunicado?.addEventListener('shown.bs.modal', () => dom.comunicadoNombre?.focus());
        };

        // FUNCION PRINCIPAL DEL PASO 3
        const _initDOM = async (container) => {
            console.log('=== PASO 3: Inicializar DOM y event listeners ===');

            try {
                // Caché de elementos DOM
                _cacheDomElements();
                // Inicializar instancias de Bootstrap
                _initBootstrapInstances();
                // Inicializar comboboxes
                _initComboboxes();
                // Agregar event listeners
                _addEventListeners();

            } catch (error) {
                console.error('❌ PASO 3 falló:', error);
                _renderErrorInicial(container, error.message || 'No fue posible inicializar el componente.');
                return;
            }

            console.log('✅ PASO 3 completado');
        }

        // =========================================================================
        // FUNCIONES DEL PASO 4
        // =========================================================================
        // SUBFUNCIÓN: Carga los catálogos del servidor con caché y manejo de concurrencia
        const _loadCatalogos = () => {
            // Si ya están cargados, retornar inmediatamente
            if (state.catalogosLoaded) {
                return Promise.resolve(state.catalogos);
            }

            if (state.catalogosPromise) {
                return state.catalogosPromise;
            }

            state.catalogosPromise = Promise.all([
                serverCall('getComunicadoCatalogs'),
                serverCall('readAllRows', 'ajustadores').catch(() => [])
            ])
                .then(([data, ajustadoresData]) => {
                    state.catalogos = {
                        estados: data.estados || [],
                        distritosRiego: data.distritosRiego || [],
                        siniestros: data.siniestros || [],
                        ajustadores: ajustadoresData || [],
                    };

                    state.catalogosLoaded = true;
                    state.catalogosPromise = null;

                    return state.catalogos;
                })
                .catch(err => {
                    state.catalogosPromise = null;
                    state.catalogosLoaded = false;

                    console.error('Error al cargar catálogos:', err);
                    throw err;
                });

            return state.catalogosPromise;
        };

        // SUBFUNCIÓN: Carga las cuentas del servidor
        const _loadCuentas = async () => {
            // Mostrar spinner mientras se cargan las cuentas
            _renderSpinner('listaCuentas', 'Cargando referencias...');

            const cuentas = await serverCall('readAllRows', 'cuentas');

            state.cuentas = cuentas || [];

            // Renderizar lista de cuentas
            _renderCuentas();

            // Actualizar badge de total
            _updateTotalCuentasBadge();
        };

        // FUNCIÓN PRINCIPAL DEL PASO 4
        const _initData = async () => {
            console.log('=== PASO 4: Cargar catálogos y cuentas en paralelo (Promise.all) ===');
            try {
                await Promise.all([
                    _loadCatalogos(),
                    _loadCuentas()
                ]);
                console.log('✅ PASO 4 completado: Catálogos y cuentas cargados');
            } catch (error) {
                console.error('❌ PASO 4 falló:', error);
                _renderError('listaCuentas', error.message || 'Error al cargar datos iniciales.');
                globalThis.showToast?.('Error al cargar datos iniciales.', 'error');
                throw error;
            }
        }

        // =========================================================================
        // FUNCIONES DEL PASO 5
        // =========================================================================
        // FUNCIÓN PRINCIPAL DEL PASO 5
        const _primeraCuentaSeleccionable = () => {
            console.log('=== PASO 5: Seleccionar primera cuenta ===');
            const selectedId = state.cuentaSeleccionadaId;
            const cuentaASeleccionar = state.cuentas.find(c => idsAreEqual(c.id, selectedId))
                || state.cuentas[0]
                || null;

            if (!cuentaASeleccionar) {
                _actualizarSeleccionCuenta(null);
                console.log('✅ PASO 5 completado: No hay cuentas para seleccionar');
            } else {
                _actualizarSeleccionCuenta(cuentaASeleccionar);
                console.log(`✅ PASO 5 completado: Cuenta "${cuentaASeleccionar.cuenta}" seleccionada`);
            }

        };

        // =========================================================================
        // FUNCIONES DEL PASO 6
        // =========================================================================
        // SUBFUNCIÓN: Carga los comunicados de una cuenta específica.
        const _loadComunicados = async (cuentaId) => {
            devLog('Cargando comunicados para cuenta ID:', cuentaId);
            if (!hasValue(cuentaId)) {
                state.comunicados = [];
                _renderComunicados();
                return;
            }
            // Mostrar spinner mientras se cargan los comunicados
            _renderSpinner('panelComunicados', 'Cargando comunicados...');
            devLog('Spinner de comunicados renderizado.');
            let comunicados;
            try {
                devLog('Llamando a serverCall para readComunicadosPorCuenta...');
                // Llamada al servidor para obtener los comunicados
                comunicados = await serverCall('readComunicadosPorCuenta', parseInt(cuentaId, 10));
                devLog('Comunicados cargados:', comunicados);
            } catch (error) {
                devLog('⚠️ Fallo el servidor al intentar cargar comunicados...', error);
                try {
                    // *VERIFICAR PORQUE FALLA ESTE RUNSERVER
                    const rawResponse = await runServer('readComunicadosPorCuenta', cuentaId);
                    devLog('Respuesta cruda de readComunicadosPorCuenta:', rawResponse);
                    if (rawResponse && typeof rawResponse === 'object' && 'success' in rawResponse) {
                        if (rawResponse.success) {
                            comunicados = rawResponse.data ?? [];
                        } else {
                            throw new Error(rawResponse.message || 'Error al obtener comunicados.');
                        }
                    } else {
                        throw error;
                    }
                } catch (secondaryError) {
                    devLog('Fallo al recuperar o interpretar la respuesta cruda de readComunicadosPorCuenta:', secondaryError);
                    throw error;
                }
            }
            state.comunicados = comunicados || [];
            // Renderizar lista de comunicados
            const comunicadoASeleccionar = state.comunicados[0] || null;
            _actualizarSeleccionComunicado(comunicadoASeleccionar);
        }
        // FUNCIÓN PRINCIPAL DEL PASO 6
        const _cargarComunicadosCuentaSeleccionada = async () => {
            console.log('=== PASO 6: Cargar comunicados de la cuenta seleccionada ===');
            const cuentaId = state.cuentaSeleccionadaId;
            if (!hasValue(cuentaId)) {
                console.log('⚠️ PASO 6 omitido: No hay cuenta seleccionada');
                return;
            }

            try {
                await _loadComunicados(cuentaId);
                console.log(`✅ PASO 6 completado: Comunicados cargados para la cuenta ID ${cuentaId}`);
            } catch (error) {
                console.error('❌ PASO 6 falló:', error);
                _renderError('panelComunicados', error.message || 'Error al cargar comunicados.');
                globalThis.showToast?.('Error al cargar comunicados.', 'error');
                return;
            }
        };

        // init DEBE ser async
        /*  Tu función init debe ser el "director de orquesta" que espera a que cada músico termine su solo. 
            Debe ser async y usar await para cada paso. 
            También debe tener un try...catch general para detener todo si un paso falla.
        */
        const init = async (container) => {
            try {
                // PASO 1: PREPARAR ESTADO INICIAL
                // (Este es síncrono, no necesita await, pero lo ponemos para claridad)
                _defEstadoInicial();

                // PASO 2: MONTAR EL COMPONENTE
                // ESPERA a que el HTML esté en la página antes de continuar
                await _mount(container);

                // PASO 3: INICIALIZAR DOM
                // ESPERA a que los elementos se cacheen y los eventos se añadan
                await _initDOM(container);

                // PASO 4: CARGAR DATOS
                // ESPERA a que las cuentas y catálogos lleguen
                await _initData();

                // PASO 5: SELECCIONAR LA PRIMERA CUENTA
                // (Síncrono, pero esperamos por si acaso se vuelve async en el futuro)
                await _primeraCuentaSeleccionable();

                // PASO 6: CARGAR LOS COMUNICADOS
                // ESPERA a que los comunicados de esa cuenta lleguen
                await _cargarComunicadosCuentaSeleccionada();

                // PASO 7: COMPONENTE LISTO
                console.log('✅ PASO 7 completado: Componente Cuentas listo para usar');

            } catch (error) {
                // Si CUALQUIER paso (mount, initDOM, initData...) falla,
                // la ejecución salta aquí y se detiene.
                console.error('❌ FALLO CRÍTICO EN LA CARGA:', error);

                // Muestra un error final al usuario
                _renderErrorInicial(container, `Error fatal al cargar: ${error.message}`);
            }
        };

        // Alias público para mantener compatibilidad con código que llama a mount()
        const mount = async (container) => init(container);



        // =========================================================================
        // API PÚBLICA
        // =========================================================================

        return {
            init,
            mount,
            unmount: () => {
                if (!state || Object.keys(state).length === 0) {
                    console.log('Componente Cuentas ya desmontado o sin estado.');
                    return;
                }
                Object.values(state.modals || {}).forEach(modal => modal?.dispose?.());
                Object.values(state.combos || {}).forEach(combo => {
                    combo?.dropdownInstance?.dispose?.();
                    clearTimeout(combo?.hideTimeout);
                });
                state = _estadoInicial();
                console.log('Componente Cuentas desmontado.');
            },

            // Exponer manejadores para onclick en HTML
            _handleCuentaClick,
            _handleComunicadoClick,
            _handleEditarCuentaClick,
            _handleEliminarCuentaClick
        };
    })();
</script>